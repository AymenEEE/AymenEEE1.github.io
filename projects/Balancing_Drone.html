<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Balancing Drone | Aymen Jaber | Professional Portfolio">
    <meta name="description" content="">
    <meta name="image" content="https://github.com/AymenEEE.png">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Aymen Jaber | Professional Portfolio">
    <meta property="og:url" content="https://AymenEEE.github.io/projects/Balancing_Drone.html">
    <meta property="og:title" content="Balancing Drone | Aymen Jaber | Professional Portfolio">
    <meta property="og:description" content="">
    <meta property="og:image" content="https://github.com/AymenEEE.png">
    <link rel="shortcut icon" href="/favicon.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/techfolio-theme/skyblue.css">
    <link rel="stylesheet" type="text/css" href="/css/rouge/github.css">
    <!-- Load MathJax if 'mathjax: true' is found in your _config.yml. -->
    
    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
    </script>
    

    <title>Balancing Drone | Aymen Jaber | Professional Portfolio</title>
  </head>
  <body>
  <header class="navbar navbar-expand navbar-light bg-light bg-gradient border-bottom">
  <div class="container-fluid">
    <a class="navbar-brand" href="/">Aymen Jaber</a>
    <div class="ms-auto">
      <ul class="navbar-nav mb-2 mb-lg-0">
        <a class="nav-link" href="/#projects">Projects</a>
        <!--<a class="nav-link" href="/#essays">Essays</a>-->
        <a class="nav-link" href="/resume.html">CV</a>
      </ul>
    </div>
  </div>
</header>

<div class="container py-4">
  <h1 class="display-4">Balancing Drone</h1>
 <h2> What? </h2>

<p>I thought of a fun (and safe) way to utilise and demonstrate PID controllers in action, and this is what came across. It moves like a see-saw but the force is only on one side. This is harder to work with than a system with two motors opposite to each other, as we are relying on gravity to pull down the stick when we want it to descend.</p>

<p>The physical system consists of a stand connected to the shaft of a wooden stick via ball-bearings, providing low friction and free movement. As for the technical side we have a microcontroller used to control the speed of the brushless motor using a PWM signal(Pulse Width Modulation) based on the readings of an angle sensor. I have used the MPU6050 (cheap and reliable!).</p>

<div class="text-center p-4">
  <img width="400px" src="../img/side_view_of_stick.jpg" class="img-thumbnail" />
  <img width="400px" src="../img/shaft.jpg" class="img-thumbnail" />
  <img width="400px" src="../img/MPU6050-Module-Pinout.jpg" class="img-thumbnail" />
</div>

<h2>How?</h2>

<p>There three parts to the control algorithm:</p>
<ul>
  <li> Read sensor data</li>
  <li> Convert readings into angle using calculations</li>
  <li> Filter sensor data</li>
  <li> Compare current reading with the desired angle</li>
  <li> Calculate the PID output</li>
  <li> Translate PID output into a duty cycle reading.</li>
</ul>

<p>This is pretty much what makes up the control system, but if you’d like to look into the technicality of the process then have a look at the code below:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;Servo.h&gt;</span><span class="c1"> // using servo.h library for convenience</span><span class="cp">
</span>
<span class="cm">/* Brushless motors (as indicated by their name) don't need brushes to power them on, but rather they relay on induction to move the shaft. 
   Operating them is not as simple as connecting a power supply.
   Rather, we need an intermediate chip to control the speed of the motor using a PWM signal from a controller. 
   In this case, we use an ESC (electronic speed controller)
*/</span>

<span class="cp">#define MAX_SIGNAL 2000 
#define MIN_SIGNAL 1000 // these values are used to calibrate the ESC
#define MOTOR_PIN 10
</span>
<span class="cp">#include</span> <span class="cpf">&lt;Wire.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"filter_lib.h"</span><span class="cp">
</span><span class="c1">// The motor creates a lot of vibration which makes angle readings VERY noisy. Using a Kalman Filter has proven to be insufficient</span>

<span class="c1">// create filter with 20 Hz cut-off frequency</span>
<span class="n">lowpass_filter</span> <span class="nf">lowpassFilter</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// create filter class</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MPU</span> <span class="o">=</span> <span class="mh">0x68</span><span class="p">;</span> <span class="c1">// MPU6050 I2C address</span>
<span class="kt">float</span> <span class="n">AccX</span><span class="p">,</span> <span class="n">AccY</span><span class="p">,</span> <span class="n">AccZ</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">AccXerr</span><span class="p">,</span> <span class="n">AccYerr</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">GyroX</span><span class="p">,</span> <span class="n">GyroY</span><span class="p">,</span> <span class="n">GyroZ</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">accAngleX</span><span class="p">,</span> <span class="n">accAngleY</span><span class="p">,</span> <span class="n">gyroAngleX</span><span class="p">,</span> <span class="n">gyroAngleY</span><span class="p">,</span> <span class="n">gyroAngleZ</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">AngleAccErrorX</span><span class="p">,</span> <span class="n">AngleAccErrorY</span><span class="p">,</span> <span class="n">GyroErrorX</span><span class="p">,</span> <span class="n">GyroErrorY</span><span class="p">,</span> <span class="n">GyroErrorZ</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">elapsedTime</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">previousTime</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">KalmanAngleRoll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KalmanUncertaintyAngleRoll</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mf">0.001</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">KalmanAnglePitch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">KalmanUncertaintyAnglePitch</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="mf">0.001</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Kalman1DOutput</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">//{angle prediction, uncertainty of prediction}</span>

<span class="kt">float</span> <span class="n">Desired_angle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Angle_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current angle error</span>
<span class="kt">float</span> <span class="n">previous_error</span><span class="p">;</span> <span class="c1">// </span>

<span class="kt">int</span> <span class="n">Throttle</span> <span class="o">=</span> <span class="mi">1350</span><span class="p">;</span> <span class="c1">// This is the base throttle value. I found this to be the sweet spot as a start</span>
<span class="kt">float</span> <span class="n">pid_p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pid_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pid_d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//&lt;-|----PID constants</span>
<span class="kt">float</span> <span class="n">kp</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ki</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kd</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span> <span class="c1">//&lt;-----------------|</span>

<span class="kt">int</span> <span class="n">DELAY</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">Servo</span> <span class="n">motor</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>
  <span class="c1">//MPU6050 setup</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>                      <span class="c1">// Initialize comunication</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">beginTransmission</span><span class="p">(</span><span class="n">MPU</span><span class="p">);</span>       <span class="c1">// Start communication with MPU6050 // MPU=0x68</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x6B</span><span class="p">);</span>                  <span class="c1">// Talk to the register 6B</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span>                  <span class="c1">// Make reset - place a 0 into the 6B register</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">endTransmission</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>        <span class="c1">//end the transmission</span>

  <span class="c1">//motor setup</span>
  <span class="n">motor</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">MOTOR_PIN</span><span class="p">);</span> <span class="c1">//</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Now writing maximum output: ("</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">MAX_SIGNAL</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" us in this case)"</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Turn on power source, then wait 2 seconds and press any key."</span><span class="p">);</span>
  <span class="n">motor</span><span class="p">.</span><span class="n">writeMicroseconds</span><span class="p">(</span><span class="n">MAX_SIGNAL</span><span class="p">);</span>

  <span class="c1">// Wait for input</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Serial</span><span class="p">.</span><span class="n">available</span><span class="p">());</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

  <span class="c1">// Send min output</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Sending minimum output: ("</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">MIN_SIGNAL</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" us in this case)"</span><span class="p">);</span><span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">motor</span><span class="p">.</span><span class="n">writeMicroseconds</span><span class="p">(</span><span class="n">MIN_SIGNAL</span><span class="p">);</span>
  <span class="n">delay</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span> <span class="c1">// give time for esc to calibrate</span>
  <span class="n">motor</span><span class="p">.</span><span class="n">writeMicroseconds</span><span class="p">(</span><span class="mi">1100</span><span class="p">);</span>
  <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"The ESC is calibrated"</span><span class="p">);</span>

  <span class="n">delay</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="n">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//read sensor values</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">beginTransmission</span><span class="p">(</span><span class="n">MPU</span><span class="p">);</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="mh">0x3B</span><span class="p">);</span> <span class="c1">// Start with register 0x3B (ACCEL_XOUT_H)</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">endTransmission</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="n">Wire</span><span class="p">.</span><span class="n">requestFrom</span><span class="p">(</span><span class="n">MPU</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// Read 6 registers total, each axis value is stored in 2 registers</span>
  <span class="c1">//For a range of +-2g, we need to divide the raw values by 16384, according to the datasheet</span>
  <span class="n">AccX</span> <span class="o">=</span> <span class="p">(</span><span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">())</span> <span class="o">/</span> <span class="mf">16384.0</span> <span class="o">-</span> <span class="mi">1839</span><span class="o">/</span><span class="mi">16384</span><span class="p">;</span> <span class="c1">// X-axis value</span>
  <span class="n">AccY</span> <span class="o">=</span> <span class="p">(</span><span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">())</span> <span class="o">/</span> <span class="mf">16384.0</span> <span class="o">+</span> <span class="mi">4198</span><span class="o">/</span><span class="mi">16384</span><span class="p">;</span> <span class="c1">// Y-axis value</span>
  <span class="n">AccZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">Wire</span><span class="p">.</span><span class="n">read</span><span class="p">())</span> <span class="o">/</span> <span class="mf">16384.0</span> <span class="o">-</span> <span class="mi">1664</span><span class="o">/</span><span class="mi">16384</span><span class="p">;</span> <span class="c1">// Z-axis value</span>
  <span class="c1">// Calculating Roll and Pitch from the accelerometer data</span>
  <span class="n">accAngleX</span> <span class="o">=</span> <span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="n">AccY</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">AccX</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">AccZ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">PI</span><span class="p">);</span> <span class="c1">// AccErrorX ~(0.58) See the calculate_IMU_error()custom function for more details</span>
  <span class="n">accAngleY</span> <span class="o">=</span> <span class="p">(</span><span class="n">atan</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">AccX</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">AccY</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">AccZ</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">PI</span><span class="p">);</span> <span class="c1">// AccErrorY ~(-1.58)</span>
  <span class="c1">// === Read gyroscope data === //</span>

  <span class="n">previousTime</span> <span class="o">=</span> <span class="n">currentTime</span><span class="p">;</span>        <span class="c1">// Previous time is stored before the actual time read</span>
  <span class="n">currentTime</span> <span class="o">=</span> <span class="n">millis</span><span class="p">();</span>            <span class="c1">// Current time actual time read</span>
  <span class="n">elapsedTime</span> <span class="o">=</span> <span class="p">(</span><span class="n">currentTime</span> <span class="o">-</span> <span class="n">previousTime</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">// Divide by 1000 to get seconds</span>
  <span class="c1">// commented out gyro reading as they aren't needed</span>
  <span class="cm">/*
  Wire.beginTransmission(MPU);
  Wire.write(0x43); // Gyro data first register address 0x43
  Wire.endTransmission(false);
  Wire.requestFrom(MPU, 6, true); // Read 4 registers total, each axis value is stored in 2 registers
  GyroX = (Wire.read() &lt;&lt; 8 | Wire.read()) / 131.0; // For a 250deg/s range we have to divide first the raw value by 131.0, according to the datasheet
  GyroY = (Wire.read() &lt;&lt; 8 | Wire.read()) / 131.0;
  GyroZ = (Wire.read() &lt;&lt; 8 | Wire.read()) / 131.0;
  // Correct the outputs with the calculated error values
  GyroX = GyroX - 76/131; // GyroErrorX ~(-0.56)
  GyroY = GyroY - 67/131; // GyroErrorY ~(2)
  GyroZ = GyroZ - 75/131; // GyroErrorZ ~ (-0.8)
  // Currently the raw values are in degrees per seconds, deg/s, so we need to multiply by sendonds (s) to get the angle in degrees
 
  gyroAngleX = gyroAngleX + GyroX * elapsedTime; // deg/s * s = deg
  gyroAngleY = gyroAngleY + GyroY * elapsedTime;
  yaw =  yaw + GyroZ * elapsedTime;
  // Complementary filter - combine acceleromter and gyro angle values
  roll = 0.10 * gyroAngleX + 0.90 * accAngleX;
  pitch = 0.96 * gyroAngleY + 0.04 * accAngleY;
  */</span>
  <span class="kt">float</span> <span class="n">prev_angle</span> <span class="o">=</span> <span class="n">KalmanAngleRoll</span><span class="p">;</span>
  
  <span class="n">kalman_1d</span><span class="p">(</span><span class="n">KalmanAngleRoll</span><span class="p">,</span><span class="n">KalmanUncertaintyAngleRoll</span><span class="p">,</span><span class="n">AccX</span><span class="p">,</span><span class="n">accAngleX</span><span class="p">);</span>
  
  <span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">Kalman1DOutput</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_angle</span><span class="p">)</span><span class="o">/</span><span class="n">elapsedTime</span><span class="p">;</span>
  
  <span class="n">KalmanAngleRoll</span> <span class="o">=</span> <span class="n">Kalman1DOutput</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">KalmanUncertaintyAngleRoll</span> <span class="o">=</span> <span class="n">Kalman1DOutput</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">KalmanAngleRoll</span> <span class="o">=</span> <span class="n">lowpassFilter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">KalmanAngleRoll</span><span class="p">);</span>
  <span class="c1">// don't need pitch reading</span>
  <span class="cm">/*
  kalman_1d(KalmanAnglePitch,KalmanUncertaintyAnglePitch,AccY,accAngleY);
  KalmanAnglePitch = Kalman1DOutput[0];
  KalmanUncertaintyAngleRoll = Kalman1DOutput[1];
  */</span>
  <span class="c1">// calculate error</span>
  <span class="n">Angle_error</span> <span class="o">=</span> <span class="n">Desired_angle</span> <span class="o">+</span> <span class="n">KalmanAngleRoll</span><span class="p">;</span>
  <span class="c1">// PID calculations</span>
  
  <span class="n">pid_p</span> <span class="o">=</span> <span class="n">kp</span><span class="o">*</span><span class="n">Angle_error</span><span class="p">;</span>
  
  <span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">&lt;</span> <span class="n">Angle_error</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">){</span>
    <span class="n">pid_i</span> <span class="o">=</span> <span class="n">pid_i</span> <span class="o">+</span> <span class="n">ki</span><span class="o">*</span><span class="n">Angle_error</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">pid_d</span> <span class="o">=</span> <span class="n">kd</span><span class="o">*</span><span class="p">(</span><span class="n">Angle_error</span> <span class="o">-</span> <span class="n">previous_error</span><span class="p">)</span><span class="o">/</span><span class="n">elapsedTime</span><span class="p">;</span>

  <span class="n">PID</span> <span class="o">=</span> <span class="n">pid_p</span> <span class="o">+</span> <span class="n">pid_i</span> <span class="o">+</span> <span class="n">pid_d</span><span class="p">;</span>
  <span class="c1">//PID = PID_LP.filter(PID);</span>
  <span class="n">PID</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">PID</span><span class="p">,</span><span class="o">-</span><span class="mi">350</span><span class="p">,</span> <span class="mi">400</span><span class="p">);</span> <span class="c1">// constraining PID value for safety</span>
  <span class="cm">/*
  if (Serial.available() &gt; 0)
  {
    int DELAY = Serial.parseInt();
    if (DELAY &gt; 999)
    {
      
      motor.writeMicroseconds(DELAY);
      float SPEED = (DELAY-1000)/10;
      Serial.print("\n");
      Serial.println("Motor speed:"); Serial.print("  "); Serial.print(SPEED); Serial.println("%"); 
      Serial.println("angle: "); Serial.print(KalmanAngleRoll);
    }     
  }
  */</span>
  <span class="n">previous_error</span> <span class="o">=</span> <span class="n">Angle_error</span><span class="p">;</span>
  
  <span class="n">DELAY</span> <span class="o">=</span> <span class="n">Throttle</span> <span class="o">+</span> <span class="n">PID</span><span class="p">;</span>
  <span class="n">DELAY</span> <span class="o">=</span> <span class="n">constrain</span><span class="p">(</span><span class="n">DELAY</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1700</span><span class="p">);</span> <span class="c1">// Safety measures</span>
  
  <span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">40</span> <span class="o">&lt;</span> <span class="n">KalmanAngleRoll</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">){</span>
    <span class="n">motor</span><span class="p">.</span><span class="n">writeMicroseconds</span><span class="p">(</span><span class="n">DELAY</span><span class="p">);</span> <span class="c1">// Safety measures</span>
  <span class="p">}</span>
 
  <span class="c1">// Serial.println("angle : "); </span>
  <span class="c1">//Serial.println(KalmanAngleRoll);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">){</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"angle:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">KalmanAngleRoll</span><span class="p">);</span>
    <span class="c1">//Serial.print("PID:"); </span>
    <span class="c1">//Serial.println(PID);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"DELAY:"</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">DELAY</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">n</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
 

<span class="kt">void</span> <span class="n">kalman_1d</span><span class="p">(</span><span class="kt">float</span> <span class="n">KalmanState</span><span class="p">,</span> <span class="kt">float</span> <span class="n">KalmanUncertainty</span><span class="p">,</span> <span class="kt">float</span> <span class="n">KalmanInput</span><span class="p">,</span> <span class="kt">float</span> <span class="n">KalmanMeasurement</span><span class="p">){</span>
  <span class="n">KalmanState</span> <span class="o">=</span> <span class="n">KalmanState</span> <span class="o">+</span> <span class="mf">0.004</span><span class="o">*</span><span class="n">KalmanInput</span><span class="p">;</span>
  <span class="n">KalmanUncertainty</span> <span class="o">=</span> <span class="n">KalmanUncertainty</span> <span class="o">+</span> <span class="mf">0.4</span><span class="o">*</span><span class="mf">0.4</span><span class="o">*</span><span class="mi">20</span><span class="o">*</span><span class="mi">20</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">KalmanGain</span> <span class="o">=</span> <span class="n">KalmanUncertainty</span> <span class="o">*</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">KalmanUncertainty</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">KalmanState</span> <span class="o">=</span> <span class="n">KalmanState</span> <span class="o">+</span> <span class="n">KalmanGain</span> <span class="o">*</span> <span class="p">(</span><span class="n">KalmanMeasurement</span> <span class="o">-</span> <span class="n">KalmanState</span><span class="p">);</span>
  <span class="n">KalmanUncertainty</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">KalmanGain</span><span class="p">)</span> <span class="o">*</span> <span class="n">KalmanUncertainty</span><span class="p">;</span>
  <span class="n">Kalman1DOutput</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">KalmanState</span><span class="p">;</span>
  <span class="n">Kalman1DOutput</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">KalmanUncertainty</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This function uses the Kalman filter equations to improve readings</span>
</code></pre></div></div>

<h2>Results</h2>
<p>Overall, the control algorithm seems to be effective.</p>

<p>Without the low-pass filter, the system experiences significant oscillation due to noisy sensor readings. The low-pass filter solves this problem, however it comes with slightly delayed sensor readings.</p>

<p>There is a satisfactory amount of distrubance rejection, with a settling time of about 5 seconds.</p>

<p>Below is the demonstration of the system in action:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/uXsSm-ZEUNU?si=KSJ9VYgaaeFNC-vx" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>


</div>

<footer class="navbar navbar-expand navbar-light bg-light bg-gradient border-top">
  <div class="container-fluid">
    <div class="ms-auto">
      <ul class="navbar-nav mb-2 mb-lg-0">
        <small><a class="nav-link" href="https://techfolios.github.io">Made with Techfolios</a></small>
      </ul>
    </div>
  </div>
</footer>


  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2" crossorigin="anonymous"></script>
  </body>
</html>
